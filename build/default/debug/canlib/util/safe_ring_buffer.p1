Version 4.0 HI-TECH Software Intermediate Code
"12 canlib/util/safe_ring_buffer.h
[; ;canlib/util/safe_ring_buffer.h: 12: typedef struct {
[s S2 `*v 1 `ui 1 `ui 1 `ui 1 `ui 1 ]
[n S2 . memory_pool element_size max_elements rd_idx wr_idx ]
"42
[; ;canlib/util/safe_ring_buffer.h: 42: _Bool srb_is_full(const srb_ctx_t *ctx);
[v _srb_is_full `(a ~T0 @X0 0 ef1`*CS2 ]
"27 C:\Program Files\Microchip\xc8\v3.00\pic\include\c99/string.h
[; ;C:\Program Files\Microchip\xc8\v3.00\pic\include\c99/string.h: 27: void *memcpy (void *restrict, const void *restrict, size_t);
[v _memcpy `(*v ~T0 @X0 0 ef3`*v`*Cv`ui ]
"6 canlib/util/safe_ring_buffer.c
[; ;canlib/util/safe_ring_buffer.c: 6: static size_t get_offset_bytes(const srb_ctx_t *ctx, size_t index) {
[v _get_offset_bytes `(ui ~T0 @X0 1 sf2`*CS2`ui ]
{
[e :U _get_offset_bytes ]
[v _ctx `*CS2 ~T0 @X0 1 r1 ]
[v _index `ui ~T0 @X0 1 r2 ]
[f ]
"7
[; ;canlib/util/safe_ring_buffer.c: 7:     if (index >= ctx->max_elements) {
[e $ ! >= _index . *U _ctx 2 4  ]
{
"8
[; ;canlib/util/safe_ring_buffer.c: 8:         return 0;
[e ) -> -> 0 `i `ui ]
[e $UE 3  ]
"9
[; ;canlib/util/safe_ring_buffer.c: 9:     }
}
[e :U 4 ]
"10
[; ;canlib/util/safe_ring_buffer.c: 10:     return index * (ctx->element_size);
[e ) * _index . *U _ctx 1 ]
[e $UE 3  ]
"11
[; ;canlib/util/safe_ring_buffer.c: 11: }
[e :UE 3 ]
}
"13
[; ;canlib/util/safe_ring_buffer.c: 13: void srb_init(srb_ctx_t *ctx, void *pool, size_t pool_size, size_t element_size) {
[v _srb_init `(v ~T0 @X0 1 ef4`*S2`*v`ui`ui ]
{
[e :U _srb_init ]
[v _ctx `*S2 ~T0 @X0 1 r1 ]
[v _pool `*v ~T0 @X0 1 r2 ]
[v _pool_size `ui ~T0 @X0 1 r3 ]
[v _element_size `ui ~T0 @X0 1 r4 ]
[f ]
"14
[; ;canlib/util/safe_ring_buffer.c: 14:     ctx->memory_pool = pool;
[e = . *U _ctx 0 _pool ]
"15
[; ;canlib/util/safe_ring_buffer.c: 15:     ctx->element_size = element_size;
[e = . *U _ctx 1 _element_size ]
"16
[; ;canlib/util/safe_ring_buffer.c: 16:     ctx->max_elements = (pool_size / (element_size));
[e = . *U _ctx 2 / _pool_size _element_size ]
"17
[; ;canlib/util/safe_ring_buffer.c: 17:     ctx->rd_idx = 0;
[e = . *U _ctx 3 -> -> 0 `i `ui ]
"18
[; ;canlib/util/safe_ring_buffer.c: 18:     ctx->wr_idx = 0;
[e = . *U _ctx 4 -> -> 0 `i `ui ]
"19
[; ;canlib/util/safe_ring_buffer.c: 19: }
[e :UE 5 ]
}
"21
[; ;canlib/util/safe_ring_buffer.c: 21: _Bool srb_push(srb_ctx_t *ctx, const void *element) {
[v _srb_push `(a ~T0 @X0 1 ef2`*S2`*Cv ]
{
[e :U _srb_push ]
[v _ctx `*S2 ~T0 @X0 1 r1 ]
[v _element `*Cv ~T0 @X0 1 r2 ]
[f ]
"22
[; ;canlib/util/safe_ring_buffer.c: 22:     if (srb_is_full(ctx)) {
[e $ ! != -> ( _srb_is_full (1 -> _ctx `*CS2 `i -> 0 `i 7  ]
{
"23
[; ;canlib/util/safe_ring_buffer.c: 23:         return 0;
[e ) -> -> 0 `i `a ]
[e $UE 6  ]
"24
[; ;canlib/util/safe_ring_buffer.c: 24:     }
}
[e :U 7 ]
"25
[; ;canlib/util/safe_ring_buffer.c: 25:     size_t offset = get_offset_bytes(ctx, ctx->wr_idx);
[v _offset `ui ~T0 @X0 1 a ]
[e = _offset ( _get_offset_bytes (2 , -> _ctx `*CS2 . *U _ctx 4 ]
"26
[; ;canlib/util/safe_ring_buffer.c: 26:     memcpy(((uint8_t *)ctx->memory_pool) + offset, element, ctx->element_size);
[e ( _memcpy (3 , , -> + -> . *U _ctx 0 `*uc * -> _offset `ux -> -> # *U -> . *U _ctx 0 `*uc `ui `ux `*v _element . *U _ctx 1 ]
"27
[; ;canlib/util/safe_ring_buffer.c: 27:     if (++(ctx->wr_idx) >= ctx->max_elements) {
[e $ ! >= =+ . *U _ctx 4 -> -> 1 `i `ui . *U _ctx 2 8  ]
{
"28
[; ;canlib/util/safe_ring_buffer.c: 28:         ctx->wr_idx = 0;
[e = . *U _ctx 4 -> -> 0 `i `ui ]
"29
[; ;canlib/util/safe_ring_buffer.c: 29:     }
}
[e :U 8 ]
"30
[; ;canlib/util/safe_ring_buffer.c: 30:     return 1;
[e ) -> -> 1 `i `a ]
[e $UE 6  ]
"31
[; ;canlib/util/safe_ring_buffer.c: 31: }
[e :UE 6 ]
}
"33
[; ;canlib/util/safe_ring_buffer.c: 33: _Bool srb_is_full(const srb_ctx_t *ctx) {
[v _srb_is_full `(a ~T0 @X0 1 ef1`*CS2 ]
{
[e :U _srb_is_full ]
[v _ctx `*CS2 ~T0 @X0 1 r1 ]
[f ]
"34
[; ;canlib/util/safe_ring_buffer.c: 34:     if ((ctx->wr_idx + 1 == ctx->rd_idx) ||
[e $ ! || == + . *U _ctx 4 -> -> 1 `i `ui . *U _ctx 3 && == + . *U _ctx 4 -> -> 1 `i `ui . *U _ctx 2 == . *U _ctx 3 -> -> 0 `i `ui 10  ]
"35
[; ;canlib/util/safe_ring_buffer.c: 35:         (ctx->wr_idx + 1 == ctx->max_elements && ctx->rd_idx == 0)) {
{
"36
[; ;canlib/util/safe_ring_buffer.c: 36:         return 1;
[e ) -> -> 1 `i `a ]
[e $UE 9  ]
"37
[; ;canlib/util/safe_ring_buffer.c: 37:     } else {
}
[e $U 11  ]
[e :U 10 ]
{
"38
[; ;canlib/util/safe_ring_buffer.c: 38:         return 0;
[e ) -> -> 0 `i `a ]
[e $UE 9  ]
"39
[; ;canlib/util/safe_ring_buffer.c: 39:     }
}
[e :U 11 ]
"40
[; ;canlib/util/safe_ring_buffer.c: 40: }
[e :UE 9 ]
}
"42
[; ;canlib/util/safe_ring_buffer.c: 42: _Bool srb_is_empty(const srb_ctx_t *ctx) {
[v _srb_is_empty `(a ~T0 @X0 1 ef1`*CS2 ]
{
[e :U _srb_is_empty ]
[v _ctx `*CS2 ~T0 @X0 1 r1 ]
[f ]
"43
[; ;canlib/util/safe_ring_buffer.c: 43:     if (ctx->wr_idx == ctx->rd_idx) {
[e $ ! == . *U _ctx 4 . *U _ctx 3 13  ]
{
"44
[; ;canlib/util/safe_ring_buffer.c: 44:         return 1;
[e ) -> -> 1 `i `a ]
[e $UE 12  ]
"45
[; ;canlib/util/safe_ring_buffer.c: 45:     } else {
}
[e $U 14  ]
[e :U 13 ]
{
"46
[; ;canlib/util/safe_ring_buffer.c: 46:         return 0;
[e ) -> -> 0 `i `a ]
[e $UE 12  ]
"47
[; ;canlib/util/safe_ring_buffer.c: 47:     }
}
[e :U 14 ]
"48
[; ;canlib/util/safe_ring_buffer.c: 48: }
[e :UE 12 ]
}
"50
[; ;canlib/util/safe_ring_buffer.c: 50: _Bool srb_pop(srb_ctx_t *ctx, void *element) {
[v _srb_pop `(a ~T0 @X0 1 ef2`*S2`*v ]
{
[e :U _srb_pop ]
[v _ctx `*S2 ~T0 @X0 1 r1 ]
[v _element `*v ~T0 @X0 1 r2 ]
[f ]
"51
[; ;canlib/util/safe_ring_buffer.c: 51:     if (srb_is_empty(ctx)) {
[e $ ! != -> ( _srb_is_empty (1 -> _ctx `*CS2 `i -> 0 `i 16  ]
{
"52
[; ;canlib/util/safe_ring_buffer.c: 52:         return 0;
[e ) -> -> 0 `i `a ]
[e $UE 15  ]
"53
[; ;canlib/util/safe_ring_buffer.c: 53:     }
}
[e :U 16 ]
"54
[; ;canlib/util/safe_ring_buffer.c: 54:     size_t offset = get_offset_bytes(ctx, ctx->rd_idx);
[v _offset `ui ~T0 @X0 1 a ]
[e = _offset ( _get_offset_bytes (2 , -> _ctx `*CS2 . *U _ctx 3 ]
"55
[; ;canlib/util/safe_ring_buffer.c: 55:     memcpy(element, ((uint8_t *)ctx->memory_pool) + offset, ctx->element_size);
[e ( _memcpy (3 , , _element -> + -> . *U _ctx 0 `*uc * -> _offset `ux -> -> # *U -> . *U _ctx 0 `*uc `ui `ux `*Cv . *U _ctx 1 ]
"56
[; ;canlib/util/safe_ring_buffer.c: 56:     if (++(ctx->rd_idx) >= ctx->max_elements) {
[e $ ! >= =+ . *U _ctx 3 -> -> 1 `i `ui . *U _ctx 2 17  ]
{
"57
[; ;canlib/util/safe_ring_buffer.c: 57:         ctx->rd_idx = 0;
[e = . *U _ctx 3 -> -> 0 `i `ui ]
"58
[; ;canlib/util/safe_ring_buffer.c: 58:     }
}
[e :U 17 ]
"59
[; ;canlib/util/safe_ring_buffer.c: 59:     return 1;
[e ) -> -> 1 `i `a ]
[e $UE 15  ]
"60
[; ;canlib/util/safe_ring_buffer.c: 60: }
[e :UE 15 ]
}
"62
[; ;canlib/util/safe_ring_buffer.c: 62: _Bool srb_peek(const srb_ctx_t *ctx, void *element) {
[v _srb_peek `(a ~T0 @X0 1 ef2`*CS2`*v ]
{
[e :U _srb_peek ]
[v _ctx `*CS2 ~T0 @X0 1 r1 ]
[v _element `*v ~T0 @X0 1 r2 ]
[f ]
"63
[; ;canlib/util/safe_ring_buffer.c: 63:     if (srb_is_empty(ctx)) {
[e $ ! != -> ( _srb_is_empty (1 _ctx `i -> 0 `i 19  ]
{
"64
[; ;canlib/util/safe_ring_buffer.c: 64:         return 0;
[e ) -> -> 0 `i `a ]
[e $UE 18  ]
"65
[; ;canlib/util/safe_ring_buffer.c: 65:     }
}
[e :U 19 ]
"66
[; ;canlib/util/safe_ring_buffer.c: 66:     size_t offset = get_offset_bytes(ctx, ctx->rd_idx);
[v _offset `ui ~T0 @X0 1 a ]
[e = _offset ( _get_offset_bytes (2 , _ctx . *U _ctx 3 ]
"67
[; ;canlib/util/safe_ring_buffer.c: 67:     memcpy(element, ctx->memory_pool + offset, ctx->element_size);
[e ( _memcpy (3 , , _element -> + . *U _ctx 0 * -> _offset `ux -> -> # *U . *U _ctx 0 `ui `ux `*Cv . *U _ctx 1 ]
"68
[; ;canlib/util/safe_ring_buffer.c: 68:     return 1;
[e ) -> -> 1 `i `a ]
[e $UE 18  ]
"69
[; ;canlib/util/safe_ring_buffer.c: 69: }
[e :UE 18 ]
}
